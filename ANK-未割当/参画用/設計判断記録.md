# 設計判断記録 (ADR) - 案件A

## 概要

本資料は、AIアプリケーション開発における重要な設計判断（Architecture Decision Records）を記録します。各判断の背景、検討した代替案、選定理由、トレードオフを明確にしています。

## ADR-001: コンテナオーケストレーションとしてEKSを採用

**ステータス**: 承認  
**日付**: 2026-01-XX  
**決定者**: インフラアーキテクト、技術リーダー

### コンテキスト

AIアプリケーションのインフラにおいて、コンテナオーケストレーションツールを選定する必要がある。以下の要件を満たす必要がある：
- マイクロサービスアーキテクチャのサポート
- 自動スケーリング機能
- 高可用性の確保
- 運用負荷の軽減
- AWS環境との統合性

### 検討した選択肢

1. **Amazon EKS（選定）**
2. **Amazon ECS**
3. **セルフマネージドKubernetes（kops、kubeadm）**

### 判断理由

**EKSを選定した理由**:
- **標準化**: KubernetesはCNCF標準で、ベンダーロックインを回避できる
- **エコシステム**: Helm、Istio、Prometheus等、豊富なKubernetesエコシステムを活用可能
- **運用負荷**: コントロールプレーンの運用が不要で、マネージドサービスにより運用負荷を軽減
- **スケーラビリティ**: Horizontal Pod Autoscaler、Cluster Autoscaler等、柔軟なスケーリングが可能
- **学習コスト**: Kubernetesスキルは汎用的で、他の環境でも活用可能

**ECSを選択しなかった理由**:
- Kubernetesの豊富なエコシステムが利用できない
- 将来的にマルチクラウド展開する場合、ECSはAWS専用のため移行が困難
- コミュニティや学習リソースがKubernetesと比較して少ない

**セルフマネージドKubernetesを選択しなかった理由**:
- コントロールプレーンの運用負荷が高い（アップグレード、パッチ適用、監視等）
- 高可用性構成の構築・維持に専門知識と時間が必要
- 初期構築コストと運用コストが高い

### トレードオフ

- **メリット**: 標準化、エコシステム、スケーラビリティ、学習コスト
- **デメリット**: ECSと比較して学習コストがやや高い、初期設定がやや複雑

### 結果

EKSを採用することで、標準的なKubernetes環境を構築でき、豊富なエコシステムを活用しながら運用負荷を軽減できる。将来的なマルチクラウド展開にも対応可能。

---

## ADR-002: CI/CDパイプラインとしてGitHub Actionsを採用

**ステータス**: 承認  
**日付**: 2026-01-XX  
**決定者**: DevOpsエンジニア、技術リーダー

### コンテキスト

CI/CDパイプラインを構築する必要がある。コードリポジトリはGitHubを使用している。以下の要件を満たす必要がある：
- GitHubリポジトリとの統合
- コンテナイメージのビルドとプッシュ
- Kubernetesへのデプロイ
- テストの自動実行
- 複数環境（Dev、Staging、Production）へのデプロイ

### 検討した選択肢

1. **GitHub Actions（選定）**
2. **Jenkins**
3. **GitLab CI**
4. **AWS CodePipeline**

### 判断理由

**GitHub Actionsを選定した理由**:
- **統合性**: GitHubリポジトリと同一プラットフォームで、シームレスな統合が可能
- **運用負荷**: マネージドサービスで、インフラ管理が不要
- **コスト**: プライベートリポジトリも月2,000分の無料枠がある
- **拡張性**: 豊富なコミュニティアクション（AWS、Kubernetes、Docker等）
- **並列実行**: ジョブの並列実行により、パイプラインを高速化可能

**Jenkinsを選択しなかった理由**:
- セルフホスト型で運用負荷が高い（サーバー管理、プラグイン更新等）
- 設定が複雑で、YAMLファイルベースのGitHub Actionsと比較して保守性が低い
- 初期構築とメンテナンスに時間がかかる

**GitLab CIを選択しなかった理由**:
- GitHubを使用している場合、別プラットフォームの管理が必要
- GitHub Actionsと比較して、GitHubとの統合がシームレスではない

**AWS CodePipelineを選択しなかった理由**:
- GitHubとの統合がGitHub Actionsほどシームレスではない
- 設定がやや複雑で、YAMLベースのGitHub Actionsと比較してコードとして管理しにくい

### トレードオフ

- **メリット**: 統合性、運用負荷軽減、コスト効率、拡張性
- **デメリット**: 無料枠を超えるとコストがかかる、カスタマイズ性はJenkinsほど高くない

### 結果

GitHub Actionsを採用することで、GitHubリポジトリとの統合を最適化し、運用負荷を軽減しながら柔軟なCI/CDパイプラインを構築できる。

---

## ADR-003: IaCとしてTerraformを採用（推奨）

**ステータス**: 推奨  
**日付**: 2026-01-XX  
**決定者**: インフラアーキテクト

### コンテキスト

Infrastructure as Code（IaC）ツールを選定する必要がある。以下の要件を満たす必要がある：
- インフラのコード化による再現性の確保
- 複数環境（Dev、Staging、Production）の管理
- バージョン管理（Git）との統合
- コードレビュープロセスの適用

### 検討した選択肢

1. **Terraform（推奨）**
2. **AWS CloudFormation**
3. **AWS CDK**

### 判断理由

**Terraformを推奨する理由**:
- **マルチクラウド対応**: 将来的なマルチクラウド展開に対応可能
- **宣言的言語**: HCL（HashiCorp Configuration Language）で読みやすく、保守しやすい
- **豊富なプロバイダー**: AWS、Kubernetes、GitHub等、多様なリソースを管理可能
- **状態管理**: Terraform状態ファイルにより、現在のインフラ状態を追跡可能
- **Plan機能**: 実行前の変更内容確認により、安全性が高い
- **モジュール化**: 再利用可能なモジュール設計により、コードの保守性が高い

**CloudFormationを選択しない理由**:
- AWS専用で、将来的なマルチクラウド展開に対応できない
- YAML/JSONが冗長になりがちで、可読性がTerraformと比較して劣る
- モジュール化がTerraformほど柔軟ではない

**CDKを選択しない理由**:
- TypeScript/Python等のプログラミング言語の知識が必要で、学習コストが高い
- Terraformと比較してコミュニティが小さい
- デバッグがやや複雑

### トレードオフ

- **メリット**: マルチクラウド対応、可読性、拡張性、状態管理
- **デメリット**: CloudFormationと比較して、AWS固有の機能への対応がやや遅れる場合がある

### 結果

Terraformを採用することで、マルチクラウド対応の柔軟性を確保しながら、保守性の高いIaCを実現できる。ただし、AWS専用環境でCloudFormationとの統合を重視する場合は、CloudFormationも選択肢として検討可能。

---

## ADR-004: データ処理パイプラインオーケストレーションとしてApache Airflowを採用（推奨）

**ステータス**: 推奨  
**日付**: 2026-01-XX  
**決定者**: データエンジニア、インフラアーキテクト

### コンテキスト

データ処理パイプラインのオーケストレーションツールを選定する必要がある。以下の要件を満たす必要がある：
- ETL処理のオーケストレーション
- スケジュール実行
- 依存関係の管理
- エラーハンドリングとリトライ
- Kubernetes環境での実行

### 検討した選択肢

1. **Apache Airflow（推奨）**
2. **AWS Step Functions**
3. **Kubeflow Pipelines**
4. **Argo Workflows**

### 判断理由

**Airflowを推奨する理由**:
- **Pythonベース**: PythonでDAGを定義でき、柔軟性が高い
- **豊富なオペレーター**: AWS、Kubernetes、データベース等、多様なオペレーターが利用可能
- **スケーラビリティ**: KubernetesExecutorにより、Kubernetesクラスターのリソースを活用可能
- **UI**: Web UIでワークフローの実行状況を可視化できる
- **コミュニティ**: オープンソースで、コミュニティが大きく活発
- **バージョン管理**: DAGをコードとして管理でき、Gitでバージョン管理可能

**Step Functionsを選択しない理由**:
- AWSネイティブで統合しやすいが、Kubernetes環境との統合がAirflowほど柔軟ではない
- 複雑なワークフロー定義がAirflowと比較して冗長になりがち
- UIでの可視化はAirflowと比較して限定的

**Kubeflow Pipelinesを選択しない理由**:
- 主にMLワークフローに特化しており、一般的なETL処理には過剰
- 学習コストがAirflowと比較して高い

**Argo Workflowsを選択しない理由**:
- Kubernetesネイティブで軽量だが、UIや機能がAirflowと比較してシンプル
- コミュニティやドキュメントがAirflowと比較して少ない

### トレードオフ

- **メリット**: 柔軟性、拡張性、可視化、コミュニティ
- **デメリット**: Step Functionsと比較して、AWSサービスとの統合がやや手動

### 結果

Airflowを採用することで、柔軟性の高いデータ処理パイプラインを構築でき、Kubernetes環境との統合も良好。ただし、AWSサービス中心のワークフローでサーバーレスアーキテクチャを重視する場合は、Step Functionsも選択肢として検討可能。

---

## ADR-005: 監視ツールとしてPrometheus + Grafanaを採用

**ステータス**: 承認  
**日付**: 2026-01-XX  
**決定者**: SRE、インフラアーキテクト

### コンテキスト

Kubernetes環境でのメトリクス監視ツールを選定する必要がある。以下の要件を満たす必要がある：
- Kubernetesメトリクスの収集
- カスタムメトリクスの収集
- ダッシュボードでの可視化
- アラート機能

### 検討した選択肢

1. **Prometheus + Grafana（選定）**
2. **CloudWatchのみ**
3. **Datadog**
4. **New Relic**

### 判断理由

**Prometheus + Grafanaを選定した理由**:
- **Kubernetes標準**: Kubernetesのメトリクス収集に標準的に使用される
- **柔軟なクエリ言語**: PromQLによる柔軟なクエリが可能
- **豊富な可視化**: Grafanaによる高機能なダッシュボード
- **オープンソース**: コストがかからず、カスタマイズ可能
- **エコシステム**: 豊富なエクスポーター（Node Exporter、cAdvisor等）

**CloudWatchのみを選択しなかった理由**:
- Kubernetesメトリクスの収集にPrometheusほど柔軟ではない
- カスタムメトリクスの収集がPrometheusほど容易ではない
- ダッシュボードの機能がGrafanaと比較して限定的

**Datadogを選択しなかった理由**:
- 有料サービスで、コストが高い
- オープンソースのPrometheus + Grafanaで要件を満たせる

**New Relicを選択しなかった理由**:
- 有料サービスで、コストが高い
- Kubernetes環境での監視はPrometheus + Grafanaで十分

### トレードオフ

- **メリット**: 標準化、柔軟性、コスト効率、カスタマイズ性
- **デメリット**: CloudWatchと比較して、AWSサービスとの統合がやや手動

### 結果

Prometheus + Grafanaを採用することで、Kubernetes標準の監視ツールを使用し、柔軟なメトリクス収集と可視化を実現できる。CloudWatchはAWSリソースの監視に併用する。

---

## ADR-006: コンテナイメージレジストリとしてAmazon ECRを採用

**ステータス**: 承認  
**日付**: 2026-01-XX  
**決定者**: DevOpsエンジニア、セキュリティエンジニア

### コンテキスト

コンテナイメージのレジストリを選定する必要がある。以下の要件を満たす必要がある：
- プライベートレジストリ
- イメージの脆弱性スキャン
- AWS環境との統合
- アクセス制御

### 検討した選択肢

1. **Amazon ECR（選定）**
2. **Docker Hub（プライベート）**
3. **GitHub Container Registry (ghcr.io)**
4. **Harbor**

### 判断理由

**ECRを選定した理由**:
- **AWS統合**: IAM、CloudWatch、EventBridge等、AWSサービスとの統合がシームレス
- **脆弱性スキャン**: イメージの自動脆弱性スキャンが標準サポート
- **コスト**: ストレージとデータ転送の従量課金で、利用量に応じたコスト
- **パフォーマンス**: AWS環境内でのイメージプルが高速
- **ライフサイクルポリシー**: 古いイメージの自動削除が可能

**Docker Hubを選択しなかった理由**:
- プライベートリポジトリは有料
- AWS環境との統合がECRほどシームレスではない

**ghcr.ioを選択しなかった理由**:
- GitHub Actionsとの統合は良好だが、AWS環境との統合がECRほどシームレスではない
- 脆弱性スキャン機能がECRほど充実していない

**Harborを選択しなかった理由**:
- セルフホスト型で運用負荷が高い
- ECRで要件を満たせるため、追加の運用負荷を避ける

### トレードオフ

- **メリット**: AWS統合、脆弱性スキャン、コスト効率、パフォーマンス
- **デメリット**: GitHub Actionsとの統合がghcr.ioほどシームレスではない（ただし、問題なく使用可能）

### 結果

ECRを採用することで、AWS環境との統合を最適化し、脆弱性スキャン機能を活用しながらセキュアなコンテナイメージ管理を実現できる。

---

## ADR-007: ネットワーク構成としてマルチAZ + プライベートサブネットを採用

**ステータス**: 承認  
**日付**: 2026-01-XX  
**決定者**: インフラアーキテクト、セキュリティエンジニア

### コンテキスト

VPCネットワーク構成を設計する必要がある。以下の要件を満たす必要がある：
- 高可用性の確保
- セキュリティの強化
- スケーラビリティ
- コスト効率

### 検討した選択肢

1. **マルチAZ + プライベートサブネット（選定）**
2. **シングルAZ + パブリックサブネット**
3. **マルチAZ + パブリックサブネットのみ**

### 判断理由

**マルチAZ + プライベートサブネットを選定した理由**:
- **高可用性**: マルチAZ配置により、単一AZ障害時の可用性を確保
- **セキュリティ**: プライベートサブネットにアプリケーション層を配置し、インターネットからの直接アクセスを遮断
- **ベストプラクティス**: AWS Well-Architected Frameworkの推奨構成
- **スケーラビリティ**: マルチAZ構成により、スケーリングの柔軟性を確保

**シングルAZ + パブリックサブネットを選択しなかった理由**:
- 単一障害点が存在し、高可用性を確保できない
- セキュリティリスクが高い（インターネットからの直接アクセス）

**マルチAZ + パブリックサブネットのみを選択しなかった理由**:
- セキュリティリスクが高い（インターネットからの直接アクセス）
- ベストプラクティスに反する

### トレードオフ

- **メリット**: 高可用性、セキュリティ、スケーラビリティ
- **デメリット**: 初期構築コストがやや高い（NAT Gateway等）

### 結果

マルチAZ + プライベートサブネット構成を採用することで、高可用性とセキュリティを確保し、AWS Well-Architected Frameworkの推奨構成に準拠できる。

---

## 参考資料

- AWS Well-Architected Framework
- CNCF Cloud Native Landscape
- Kubernetes Best Practices
- Infrastructure as Code Best Practices
- Site Reliability Engineering (SRE) Practices
